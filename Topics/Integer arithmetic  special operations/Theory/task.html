<div class="step-text">
<p>Welcome back to our exploration of integer arithmetic in Python! </p><p>Now that you've mastered the basics like addition (+), subtraction (-), multiplication (*), division (/), and integer division (//), it's time to dive a little bit deeper.</p><p>In today's lesson, we'll introduce two powerful operators: <strong>exponentiation (**)</strong> and <strong>modulo (%)</strong>. These tools are especially useful in everything from game development to cryptography, and once you learn how to use them, you'll wonder how you ever lived without them.</p><h5 id="exponentiation">Exponentiation (**)</h5><p>The exponentiation operator allows you to raise a number (the base) to the power of another number (the exponent). Think of it like repeated multiplication.</p><p><strong>Syntax</strong></p><pre><code class="language-python">result = base ** exponent</code></pre><p><strong>Examples</strong></p><pre><code class="language-python">print(2 ** 3)  # Output: 8, because 2  2  2 = 8
print(5 ** 0)  # Output: 1, any number to the power of 0 is 1
print(10 ** 2) # Output: 100</code></pre><p>⚠️ Python can handle large exponents, but be cautious: the result can grow very quickly and consume a lot of memory.</p><p>Let's see some practical use cases of this operator:</p><p><strong>Squares and Cubes</strong></p><p>You can easily calculate squares (power of 2) and cubes (power of 3) of numbers using **.</p><pre><code class="language-python">print(5 ** 2)  # Output: 25 → 5 squared
print(2 ** 3)  # Output: 8  → 2 cubed
print(10 ** 2) # Output: 100 → 10 squared</code></pre><p>Handy when dealing with geometry, physics, or just quick math tricks.</p><p><strong>Growing Numbers Quickly</strong></p><p>Exponentiation grows numbers <strong>really fast</strong>!</p><pre><code class="language-python">print(2  5)  # Output: 32
print(3  4)  # Output: 81
print(10 ** 6) # Output: 1000000</code></pre><p>This comes in useful when working with large values like powers of 10 (e.g. "a million" is 10 ** 6) or understanding exponential growth.</p><p><strong>Area and Volume Formulas</strong></p><p>You’ll often see powers in math and physics formulas.</p><ul><li><p>Area of a square = side²</p></li><li><p>Volume of a cube = side³</p></li></ul><pre><code class="language-python">side = 4 
print(side ** 2)  # Area: 16 
print(side ** 3)  # Volume: 64</code></pre><p>These are simple applications where ** makes your code much cleaner and easier to read.</p><h5 id="modulo">Modulo (%)</h5><p>The modulo operator gives you the <strong>remainder</strong> of a division operation.</p><p><strong>Syntax</strong></p><pre><code class="language-python">remainder = dividend % divisor</code></pre><p><strong>Examples</strong></p><pre><code class="language-python">print(10 % 3)  # Output: 1, because 10 = 3 * 3 + 1
print(14 % 5)  # Output: 4
print(21 % 7)   # Output: 0, since 21 is divisible by 7</code></pre><p>The modulo operator is great when you need to:</p><p><strong>Check if a number is even or odd</strong></p><p>Let’s see what happens when we divide some numbers by 2 and print the remainder:</p><pre><code class="language-python">print(4 % 2)  # Output: 0  
print(7 % 2)  # Output: 1  
print(10 % 2) # Output: 0  
print(13 % 2) # Output: 1 </code></pre><p>If the result is 0, the number is even. If it’s 1, it’s odd.</p><p><strong>Wrap values around in games or cyclic tasks</strong></p><p>Imagine you're moving through 3 levels in a game: 0, 1, 2. After 2, you want to start again from 0.</p><pre><code class="language-python">print((0 + 1) % 3)  # Output: 1 
print((1 + 1) % 3)  # Output: 2 
print((2 + 1) % 3)  # Output: 0 (wraps around!) 
print((3 + 1) % 3)  # Output: 1</code></pre><p>This is a simple way to make numbers repeat in a cycle — perfect for menus, animations, or timed events.</p><p><strong>Periodic patterns </strong></p><p>Want to see which numbers are multiples of 3?</p><pre><code class="language-python">print(3 % 3)   # Output: 0 
print(6 % 3)   # Output: 0 
print(9 % 3)   # Output: 0 
print(10 % 3)  # Output: 1 
print(11 % 3)  # Output: 2</code></pre><p>When the remainder is 0, the number is divisible by 3. Try printing % results for more numbers and see if you can spot the pattern!</p><h5 id="a-quick-note-on-negative-numbers">A Quick Note on Negative Numbers</h5><p>Both operators behave a little differently when negative numbers are involved.</p><p><strong>Exponentiation</strong></p><pre><code class="language-python">print(-2 ** 2)  # Output: -4 (not 4!)
print((-2) ** 2) # Output: 4</code></pre><p>Why? Because <strong>Python applies exponentiation before negation. </strong>So <span class="math-tex">\(-2 ** 2\)</span><strong> </strong>is interpreted as <span class="math-tex">\(-(2 ** 2)\)</span>.</p><p><strong>Modulo</strong></p><pre><code class="language-python">print(-10 % 3)  # Output: 2
print(10 % -3)  # Output: -2</code></pre><p>Python ensures the result of % always has the <strong>same sign as the divisor</strong>.</p><h5 id="summary">Summary</h5><p>In this lesson, you’ve learned:</p><ul><li><p><span class="math-tex">\(**\)</span> lets you raise numbers to a power.</p></li><li><p><span class="math-tex">\(\%\)</span><span class="math-tex">\(%\)</span> helps you find the remainder in division.</p></li><li><p>Python's operator precedence and sign behavior can impact your results.</p></li></ul><p>Keep experimenting, and don’t worry if you make mistakes — that’s part of the learning process!</p>
</div>