<div class="step-text">
<p>One important concept of object-oriented programming is <strong>overriding. </strong>Overriding is the ability of a class to change the implementation of the methods inherited from its ancestor classes.</p>
<p>This feature is extremely useful as it allows us to explore inheritance to its full potential. Not only can we reuse existing code and method implementations, but also upgrade and advance them if needed.</p>
<p>Overriding is a concept applicable only to class hierarchies: without inheritance, we cannot talk about <a class="theory-lookup not-relevant" href="/learn/step/7629" target="_blank" title="In Python, method overriding is the ability of a class to change the implementation of a method that was inherited from its ancestor class. | This feature allows you to explore inheritance to its full potential, as you can reuse existing code and method implementation while upgrading and advancing them if needed. Method overriding is applicable only to class hierarchy, and it enables you to enhance the method of the parent class without discarding the original implementation.">method overriding</a>. Let's consider an example of a <a class="theory-lookup not-relevant" href="/learn/step/7629" target="_blank" title="In Python, a class hierarchy is a relationship between classes where a child class inherits attributes and methods from a parent class, using arrow notation that points from the child class to the parent class. | This relationship can be multiple levels deep, creating a hierarchy of classes where a child class can have multiple parent classes, and a parent class can be a grandparent to a child class. This inheritance allows for code reuse and a more organized codebase, as child classes can inherit and build upon the attributes and methods of their parent classes.">class hierarchy</a>:</p>
<pre><code class="language-python">class Parent:
    def do_something(self):
        print("Did something")


class Child(Parent):
    def do_something(self):
        print("Did something else")


parent = Parent()
child = Child()

parent.do_something()  # Did something
child.do_something()  # Did something else</code></pre>
<p>Here, the method <code class="language-python">do_something</code> is overridden in the class <code class="language-python">Child</code>. If we hadn't overridden it, the method would have the same implementation as in the class <code class="language-python">Parent</code>. The code <code class="language-python">child.do_something()</code> would then print <code class="language-python">Did something</code>.</p>
<h5 id="super" style="text-align: center;">super()</h5>
<p>Python has a special function for calling the method of the parent class inside the methods of the <a class="theory-lookup not-relevant" href="/learn/step/7629" target="_blank" title="In Python, a child class, also known as a derived class or subclass, is a class that inherits attributes and methods from a parent class, also known as a base class or superclass. | Child classes can override or extend the functionality of their parent class, and they can also inherit the functionality of multiple parent classes in the case of multiple inheritance. This allows for code reusability and a more organized class hierarchy, following the DRY (Don't Repeat Yourself) principle. In the provided context, the child class is referred to as a class that inherits from other classes, specifically a class that inherits from both 'class' and 'class', making it a case of multiple inheritance.">child class</a>: the <strong><code class="language-python">super()</code></strong> function. It returns a proxy, a temporary object of the parent class, and allows us to call a method of the parent class using this proxy. Let's take a look at the following example:</p>
<pre><code class="language-python">class Parent:
    def __init__(self, name):
        self.name = name
        print("Called Parent __init__")


class Child(Parent):
    def __init__(self, name):
        super().__init__(name)
        print("Called Child __init__")</code></pre>
<p>We've overridden the <code class="language-python">__init__()</code> method in the child class but inside it we've called the <code class="language-python">__init__()</code> of the <a class="theory-lookup not-relevant" href="/learn/step/7629" target="_blank" title="In Python, a parent class, also known as a base class, is a class that serves as the foundation for other classes, which are referred to as child classes or derived classes. | These child classes inherit methods and attributes from their parent class. In cases of multiple inheritance, a class can have more than one parent class, allowing for complex class hierarchies. It is important to call the parent implementation when overriding methods in order to avoid unexpected consequences and to ensure the original implementation and any enhancements coexist.">parent class</a>. If we create an object of the class <code class="language-python">Child</code>, we will get the following output:</p>
<pre><code class="language-python">jack = Child("Jack")
# Called Parent __init__
# Called Child __init__</code></pre>
<p>In Python 3 the method <code class="language-python">super()</code> doesn't have any required parameters. In earlier versions, however, you had to specify the class from which the method would search for a superclass. In our example, instead of <code class="language-python">super().__init__(name)</code> we would write <code class="language-python">super(Child, self).__init__(name)</code>. Both lines of code mean the same thing: that we want to find the superclass of the class <code class="language-python">Child</code> and then call its <code class="language-python">__init__</code> method. In Python 3 these are equivalent, so you don't have to explicitly write the type. However, it may be useful if you want to access the method of the "grandparent" class: the parent class of the parent class.</p>
<h5 id="super-with-single-inheritance" style="text-align: center;">super() with single inheritance</h5>
<p>The method <code class="language-python">super()</code> is mostly used in cases of multiple inheritance: when a class inherits from two or more classes. There it is most convenient and useful but you'll have a chance to learn about that in the next topics. This method can also be of use with <a class="theory-lookup not-relevant" href="/learn/step/7629" target="_blank" title="In Python, single inheritance refers to a child class acquiring properties and methods from a single parent class. | This means that the child class inherits attributes and behaviors of the parent class, and can also define its own unique attributes and methods. The child class can override or extend methods inherited from the parent class, providing a way to customize and specialize the behavior of the parent class. This concept enables code reuse and a more organized code structure, adhering to the DRY (Don't Repeat Yourself) principle.">single inheritance</a> which is what we'll cover now.</p>
<p>Suppose we have the following classes:</p>
<pre><code class="language-python">class Animal:
    def __init__(self, species):
        self.species = species

       
class Cat(Animal):
    def __init__(self, name):
        self.name = name
        </code></pre>
<p>In the subclass <code class="language-python">Cat</code>, we've overridden the <code class="language-python">__init__()</code> method. Now the objects of the class <code class="language-python">Cat</code> do not have the <code class="language-python">species</code> attribute. We would like for objects of the <code class="language-python">Cat</code> class to have this attribute, but adding it as a parameter of the <code class="language-python">__init__</code> seems a bit excessive. We could, of course, simply create this attribute inside the initializer, but there is a more elegant (and more Pythonic) solution. This solution, as expected, is the <code class="language-python">super()</code> method:</p>
<pre><code class="language-python">class Animal:
    def __init__(self, species):
        self.species = species
        print("Animal __init__")


class Cat(Animal):
    def __init__(self, name):
        super().__init__("cat")
        self.name = name
        print("Cat __init__")</code></pre>
<p>Let's create a cat and see how this has worked:</p>
<pre><code class="language-python">fluffy = Cat("Fluffy")
# Animal __init__
# Cat __init__

print(fluffy.species, fluffy.name)  # cat Fluffy</code></pre>
<p>Both <code class="language-python">__init__()</code> methods have done their job and our cat has both the <code class="language-python">species</code> and the <code class="language-python">name</code> attributes.</p>
<p>You may wonder why we had to do it this way. Why did we have to call the parent implementation of the method when we could manage without it? Well, the example above is a very simple one. In real-life projects, classes, their methods and the relationships between them are much more sophisticated.</p>
<p>Overriding does provide us with an opportunity to enhance the methods of the parent class but it doesn't mean that we should discard the original implementations. Sometimes, you may not have full access to the original implementation and you may not know everything that happens there. If you just override it, there may be unexpected consequences. So, it is recommended to always call the parent implementation. This way, you get the best of both worlds: you have the original implementation and your enhancements.</p>
<p>Just be careful and thoughtful when overriding methods and using the <code class="language-python">super()</code> function and you'll do great!</p>
<h5 id="summary">Summary</h5>
<p>Thus, in this topic, we've covered the concept of overriding in object-oriented programming, learned about a special <code class="language-python">super()</code> function that can call the parent class method inside of child class methods and how to use it in case of single inheritance. Hopefully, you'll find this information useful in your future projects!</p>
</div>